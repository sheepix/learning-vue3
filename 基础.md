# 零、资源

官方：https://v3.cn.vuejs.org/guide/introduction.html

# 一、安装

将 Vue.js 添加到项目中主要有四种方式：

1. 在页面上以 [CDN 包](https://v3.cn.vuejs.org/guide/installation.html#cdn)的形式导入。
2. 下载 JavaScript 文件并[自行托管](https://v3.cn.vuejs.org/guide/installation.html#下载并自托管)。
3. 使用 [npm](https://v3.cn.vuejs.org/guide/installation.html#npm) 安装它。
4. 使用官方的 [CLI](https://v3.cn.vuejs.org/guide/installation.html#命令行工具-cli) 来构建一个项目。



- 安装Devtools

  [获取 Chrome 扩展程序](https://chrome.google.com/webstore/detail/vuejs-devtools/ljjemllljcmogpfapbkkighbhhppjdbg)

  [获取 Firefox 附加组件](https://addons.mozilla.org/en-US/firefox/addon/vue-js-devtools/)

  [获取独立的 Electron 应用程序](https://github.com/vuejs/vue-devtools/blob/dev/packages/shell-electron/README.md)

- CDN

  获取最新Vue，用于开发环境

```html
<script src="https://unpkg.com/vue@next"></script>
```

- 下载并自行托管

- npm

  ```bash
  # 最新稳定版
  $ npm install vue@next
  ```

  Vue 还提供了编写[单文件组件](https://v3.cn.vuejs.org/guide/single-file-component.html)的配套工具

  ```bash
  $ npm install -D @vue/compiler-sfc
  ```

- CLI

  1. 安装cli

     ```bash
     yarn global add @vue/cli
     # 或
     npm install -g @vue/cli
     ```

  2. 在vue项目中运行

     ```bash
     vue upgrade --next
     ```

## Vite

[Vite](https://github.com/vitejs/vite) 是一个 web 开发构建工具，由于其原生 ES 模块导入方式，可以实现闪电般的冷服务器启动。

通过在终端中运行以下命令，可以使用 Vite 快速构建 Vue 项目。

```bash
# npm 6.x
$ npm init vite@latest <project-name> --template vue

# npm 7+，需要加上额外的双短横线
$ npm init vite@latest <project-name> -- --template vue

$ cd <project-name>
$ npm install
$ npm run dev
```

or yarn

```bash
$ yarn create vite <project-name> --template vue
$ cd <project-name>
$ yarn
$ yarn dev
```



# 二、介绍

## 声明式渲染

```html
<div id="counter">
  Counter: {{ counter }}
</div>
```

```js
const Counter = {
  data() {
    return {
      counter: 0
    }
  },
  mounted() {
    setInterval(() => {
      this.counter++
    }, 1000)
  }
}

Vue.createApp(Counter).mount('#counter')
```

- `v-bind:attribute` 被称为`指令`

- 指令带有前缀`v-`

- `v-on`添加一个事件监听器

  ```html
  <div id="event-handling">
    <p>{{ message }}</p>
    <button v-on:click="reverseMessage">反转 Message</button>
  </div>
  ```

  ```js
  const EventHandling = {
    data() {
      return {
        message: 'Hello Vue.js!'
      }
    },
    methods: {
      reverseMessage() {
        this.message = this.message
          .split('')
          .reverse()
          .join('')
      }
    }
  }
  
  Vue.createApp(EventHandling).mount('#event-handling')
  ```

- `v-model`双向绑定

## 条件与循环

- `v-if`

  ```html
  <div id="conditional-rendering">
    <span v-if="seen">现在你看到我了</span>
  </div>
  ```

- `v-for`

  ```html
  <div id="list-rendering">
    <ol>
      <li v-for="todo in todos">
        {{ todo.text }}
      </li>
    </ol>
  </div>
  ```

## 组件化应用构建

```js
// 创建 Vue 应用
const app = Vue.createApp(...)

// 定义名为 todo-item 的新组件
app.component('todo-item', {
  template: `<li>This is a todo</li>`
})

// 挂载 Vue 应用
app.mount(...)
```

使用组件

```html
<ol>
  <!-- 创建一个 todo-item 组件实例 -->
  <todo-item></todo-item>
</ol>
```

- 接收参数`prop`

  ```js
  const TodoList = {
    data() {
      return {
        groceryList: [
          { id: 0, text: 'Vegetables' },
          { id: 1, text: 'Cheese' },
          { id: 2, text: 'Whatever else humans are supposed to eat' }
        ]
      }
    }
  }
  
  const app = Vue.createApp(TodoList)
  
  app.component('todo-item', {
    props: ['todo'],
    template: `<li>{{ todo.text }}</li>`
  })
  
  app.mount('#todo-list-app')
  ```

  ```html
  <div id="todo-list-app">
    <ol>
       <!--
        现在我们为每个 todo-item 提供 todo 对象
        todo 对象是变量，即其内容可以是动态的。
        我们也需要为每个组件提供一个“key”，稍后再
        作详细解释。
      -->
      <todo-item
        v-for="item in groceryList"
        v-bind:todo="item"
        v-bind:key="item.id"
      ></todo-item>
    </ol>
  </div>
  ```

# 三、应用&组件实例

## 创建一个应用实例

每个 Vue 应用都是通过用 `createApp` 函数创建一个新的**应用实例**开始的：

```js
Vue.createApp({})
  .component('SearchInput', SearchInputComponent)
  .directive('focus', FocusDirective)
  .use(LocalePlugin)
```

## 根组件

- 传递给 `createApp` 的选项用于配置**根组件**。当我们**挂载**应用时，该组件被用作渲染的起点。

- 一个应用需要被挂载到一个 DOM 元素中

  ```js
  const RootComponent = { 
    /* 选项 */ 
  }
  const app = Vue.createApp(RootComponent)
  const vm = app.mount('#app')
  ```

- `mount`返回的是根组件实例
- 每个组件将有自己的组件实例 `vm`

## 组件实例

- 在 `data` 中定义的 property 是通过组件实例暴露的

  ```js
  const app = Vue.createApp({
    data() {
      return { count: 4 }
    }
  })
  
  const vm = app.mount('#app')
  
  console.log(vm.count) // => 4
  ```

- 其他组件选项：`methods`，`props`，`computed`，`inject` 和 `setup`

- 内置property：如 `$attrs` 和 `$emit`

## 生命周期钩子

- 每个组件在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等

- 过程中也会运行一些叫做**生命周期钩子**的函数。让用户可以介入

  ```js
  Vue.createApp({
    data() {
      return { count: 1}
    },
    created() {
      // `this` 指向 vm 实例
      console.log('count is: ' + this.count) // => "count is: 1"
    }
  })
  ```

- 还有实力生命周期的不同阶段的钩子： [mounted](https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html#mounted)、[updated](https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html#updated) 和 [unmounted](https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html#unmounted)

- 生命周期钩子的 `this` 上下文指向调用它的当前活动实例。
- 不要在选项 property 或回调上使用[箭头函数](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

## 生命周期图示

![实例的生命周期](https://raw.githubusercontent.com/sheepix/BlogImage/main/lifecycle.svg)

# 四、模版语法

## 插值

**文本**

1. Mustache

```html
<span>Message: {{ msg }}</span>
```

- Mustache 标签将会被替代为对应组件实例中 `msg` property 的值
- 无论何时，绑定的组件实例上 `msg` property 发生了改变，插值处的内容都会更新。
- Mustache不能用在Attribute里

2. `v-once`: 一次性插值，后续不会改变

```html
<span v-once>这个将不会改变: {{ msg }}</span>
```

**原始HTML**

- Mustache会将数据解释为普通文本
- 需要输出html则需要`v-html`标签

```html
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

**Attribute**

- `v-bind`指令

```html
<div v-bind:id="dynamicId"></div>
```

- 如果绑定的值为`null`or`undefined`,则attribute不会包含在渲染的元素上
  - 对于布尔attribute，[truthy](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)和空字符串都会让attribute包含，而[falsy](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy)都会被忽略

**使用JavaScript表达式**

```html
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div v-bind:id="'list-' + id"></div>
```

- 每个绑定都只能包含单个表达式

## 指令

- Directives, 带有`v-`前缀的attribute
- 预期值都是**单个JavaScript表达式**(`v-for`,`v-on`除外)

**参数**

```html
<!-- href为v-bind的参数 -->
<a v-bind:href="url"> ... </a>
<!-- click为v-on的参数 -->
<a v-on:click="doSomething"> ... </a>
```

**动态参数**

- 也可以在指令参数中使用 JavaScript 表达式，方法是用方括号`[]`括起来

```html
<a v-on:[eventName]="doSomething"> ... </a>
```

**修饰符**

- 修饰符 (modifier) 是以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。

```html
<!-- .prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault() -->
<form v-on:submit.prevent="onSubmit">...</form>
```

**缩写**

- `v-bind`

```html
<!-- 完整语法 -->
<a v-bind:href="url"> ... </a>

<!-- 缩写 -->
<a :href="url"> ... </a>

<!-- 动态参数的缩写 -->
<a :[key]="url"> ... </a>
```

- `v-on`：如

```html
<!-- 完整语法 -->
<a v-on:click="doSomething"> ... </a>

<!-- 缩写 -->
<a @click="doSomething"> ... </a>

<!-- 动态参数的缩写 (2.6.0+) -->
<a @[event]="doSomething"> ... </a>
```

**注意事项**

- 动态参数值约定：
  - 动态参数预期会求出一个字符串。
  - `null`会移除绑定
  - 任何其它非字符串类型的值都将会触发一个警告
- 动态参数表达式约定：
  - 动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的
  - 变通的办法是使用没有空格或引号的表达式，或用[计算属性](https://v3.cn.vuejs.org/guide/computed.html)替代这种复杂表达式。

```html
<!--
在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。
除非在实例中有一个名为“someattr”的 property，否则代码不会工作。
-->
<a v-bind:[someAttr]="value"> ... </a>
```

- JavaScript表达式
  - 模板表达式都被放在沙盒中，只能访问一个[受限的列表](https://github.com/vuejs/vue-next/blob/master/packages/shared/src/globalsWhitelist.ts#L3)，如 `Math` 和 `Date`。
  - 你不应该在模板表达式中试图访问用户定义的全局变量。

# 五、Data Property和方法

## Data Property

- 组件的 `data` 选项是一个函数，返回一个对象。
- Vue通过响应性系统将返回对象包裹起来，并以`$data`的形式存储在组件实例中。
- 该对象的任何顶级property也直接通过组件实例暴露出来

```js
const app = Vue.createApp({
  data() {
    return { count: 4 }
  }
})

const vm = app.mount('#app')

console.log(vm.$data.count) // => 4
console.log(vm.count)       // => 4

// 修改 vm.count 的值也会更新 $data.count
vm.count = 5
console.log(vm.$data.count) // => 5

// 反之亦然
vm.$data.count = 6
console.log(vm.count) // => 6
```

- 响应性系统只会跟踪`$data`对象内的property，所以在data函数外添加的property将不会被自动跟踪
- Vue 使用 `$` 前缀通过组件实例暴露自己的内置 API。它还为内部 property 保留 `_` 前缀。你应该避免使用这两个字符开头的的顶级 `data` property 名称。

## 方法

- 通过`methods` 选项向组件实例添加方法

```js
const app = Vue.createApp({
  data() {
    return { count: 4 }
  },
  methods: {
    increment() {
      // `this` 指向该组件实例
      this.count++
    }
  }
})

const vm = app.mount('#app')
console.log(vm.count) // => 4
vm.increment()
console.log(vm.count) // => 5
```

- Vue 自动为 `methods` 绑定 `this`
- 在定义 `methods` 时应避免使用箭头函数，因为这会阻止 Vue 绑定恰当的 `this` 指向。
- `methods` 和组件实例的其它所有 property 一样可以在组件的模板中被访问。在模板中，它们通常被当做事件监听使用：

```html
<button @click="increment">Up vote</button>
```

## 防抖和节流

- 使用Lodash库实现

```html
<!-- 可复用组件共享相同的防抖函数 -->
<script src="https://unpkg.com/lodash@4.17.20/lodash.min.js"></script>
<script>
  Vue.createApp({
    methods: {
      // 用 Lodash 的防抖函数
      click: _.debounce(function() {
        // ... 响应点击 ...
      }, 500)
    }
  }).mount('#app')
</script>
```

```js
app.component('save-button', {
  created() {
    // 用 Lodash 的防抖函数
    this.debouncedClick = _.debounce(this.click, 500)
  },
  unmounted() {
    // 移除组件时，取消定时器
    this.debouncedClick.cancel()
  },
  methods: {
    click() {
      // ... 响应点击 ...
    }
  },
  template: `
    <button @click="debouncedClick">
      Save
    </button>
  `
})
```

# 六、计算属性和侦听器

## 计算属性

```html
<div id="computed-basics">
  <p>Has published books:</p>
  <span>{{ publishedBooksMessage }}</span>
</div>
```

```js
Vue.createApp({
  data() {
    return {
      author: {
        name: 'John Doe',
        books: [
          'Vue 2 - Advanced Guide',
          'Vue 3 - Basic Guide',
          'Vue 4 - The Mystery'
        ]
      }
    }
  },
  computed: {
    // 计算属性的 getter
    publishedBooksMessage() {
      // `this` 指向 vm 实例
      return this.author.books.length > 0 ? 'Yes' : 'No'
    }
  }
}).mount('#computed-basics')
```

- 计算属性是机遇响应依赖关系缓存的。依赖不变就不会重新计算。
- 计算属性默认只有getter，可按需设定setter

```js
computed: {
  fullName: {
    // getter
    get() {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set(newValue) {
      const names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
```

## 侦听器

- 当需要在数据变化时执行异步或开销较大的操作时，推荐用`watch`

```html
<div id="watch-example">
  <p>
    Ask a yes/no question:
    <input v-model="question" />
  </p>
  <p>{{ answer }}</p>
</div>
```

```html
<!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 -->
<!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 -->
<script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
<script>
  const watchExampleVM = Vue.createApp({
    data() {
      return {
        question: '',
        answer: 'Questions usually contain a question mark. ;-)'
      }
    },
    watch: {
      // whenever question changes, this function will run
      question(newQuestion, oldQuestion) {
        if (newQuestion.indexOf('?') > -1) {
          this.getAnswer()
        }
      }
    },
    methods: {
      getAnswer() {
        this.answer = 'Thinking...'
        axios
          .get('https://yesno.wtf/api')
          .then(response => {
            this.answer = response.data.answer
          })
          .catch(error => {
            this.answer = 'Error! Could not reach the API. ' + error
          })
      }
    }
  }).mount('#watch-example')
</script>
```

- [Watch API](https://v3.cn.vuejs.org/api/instance-methods.html#watch)



